package controllers

/*
Copyright 2022 The k8gb Contributors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Generated by GoLic, for more details see: https://github.com/AbsaOSS/golic
*/

import (
	"context"
	"reflect"
	"strconv"

	k8gbv1beta1 "github.com/k8gb-io/k8gb/api/v1beta1"
	netv1 "k8s.io/api/networking/v1"
	"k8s.io/apimachinery/pkg/api/errors"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

// Converts between ingress and gslb.
type mapper struct {
	client.Client
}

type mapperResult int

const (
	mapperResultUpdate mapperResult = iota
	mapperResultCreate
	mapperResultError
)

func newMapper(c client.Client) *mapper {
	return &mapper{Client: c}
}

func (m *mapper) getGslb(namespace, name string) (gslb *k8gbv1beta1.Gslb, r mapperResult, err error) {
	gslb = &k8gbv1beta1.Gslb{}
	err = m.Get(context.TODO(), client.ObjectKey{
		Namespace: namespace,
		Name:      name,
	}, gslb)
	r, err = m.getConverterResult(err)
	return gslb, r, err
}

func (m *mapper) getIngress(namespace, name string) (ingress *netv1.Ingress, r mapperResult, err error) {
	ingress = &netv1.Ingress{}
	err = m.Get(context.TODO(), client.ObjectKey{
		Namespace: namespace,
		Name:      name,
	}, ingress)
	r, err = m.getConverterResult(err)
	if ingress.Annotations == nil {
		ingress.Annotations = make(map[string]string, 0)
	}
	return ingress, r, err
}

func (m *mapper) mapGslbAsIngress(gslb *k8gbv1beta1.Gslb) (ingress *netv1.Ingress, r mapperResult, err error) {
	var predefinedStrategy = k8gbv1beta1.Strategy{
		DNSTtlSeconds:              30,
		SplitBrainThresholdSeconds: 300,
	}
	ingress, r, err = m.getIngress(gslb.Namespace, gslb.Name)
	if err != nil {
		return ingress, r, err
	}
	ingress.Namespace = gslb.Namespace
	ingress.Name = gslb.Name

	ingress.Spec = k8gbv1beta1.ToV1IngressSpec(gslb.Spec.Ingress)
	if gslb.Spec.Strategy.DNSTtlSeconds != predefinedStrategy.DNSTtlSeconds {
		ingress.Annotations[dnsTTLSecondsAnnotation] = strconv.Itoa(gslb.Spec.Strategy.DNSTtlSeconds)
	}
	if gslb.Spec.Strategy.SplitBrainThresholdSeconds != predefinedStrategy.SplitBrainThresholdSeconds {
		ingress.Annotations[splitBrainThresholdSecondsAnnotation] = strconv.Itoa(gslb.Spec.Strategy.SplitBrainThresholdSeconds)
	}
	ingress.Annotations[primaryGeoTagAnnotation] = gslb.Spec.Strategy.PrimaryGeoTag
	ingress.Annotations[strategyAnnotation] = gslb.Spec.Strategy.Type
	return ingress, r, err
}

func (m *mapper) mapIngressAsGslb(ingress *netv1.Ingress) (gslb *k8gbv1beta1.Gslb, r mapperResult, err error) {
	gslb, r, err = m.getGslb(ingress.Namespace, ingress.Name)
	if err != nil {
		return gslb, r, err
	}
	gslb.Namespace = ingress.Namespace
	gslb.Name = ingress.Name
	gslb.Spec.Ingress = k8gbv1beta1.FromV1IngressSpec(ingress.Spec)
	gslb.Spec.Strategy, err = parseStrategy(ingress.Annotations)
	return gslb, r, err
}

func (m *mapper) equal(ingress *netv1.Ingress, gslb *k8gbv1beta1.Gslb) bool {
	if ingress == nil || gslb == nil {
		return false
	}
	// strategy
	ingressStrategy, err := parseStrategy(ingress.Annotations)
	if err != nil {
		return false
	}
	if !reflect.DeepEqual(ingressStrategy, gslb.Spec.Strategy) {
		return false
	}
	// ingress
	ingressSpec := k8gbv1beta1.FromV1IngressSpec(ingress.Spec)
	return reflect.DeepEqual(ingressSpec, gslb.Spec.Ingress)
}

func (m *mapper) getNewestGslb(gslb *k8gbv1beta1.Gslb) *k8gbv1beta1.Gslb {
	upstreamGslb, r, _ := m.getGslb(gslb.Namespace, gslb.Name)
	if r != mapperResultUpdate {
		return gslb
	}
	if gslb.CreationTimestamp.After(upstreamGslb.CreationTimestamp.Time) {
		return gslb
	}
	return upstreamGslb
}

// todo: check if you can refactor by reading general object.
func (m *mapper) getNewestIngress(ing *netv1.Ingress) *netv1.Ingress {
	upstreamIngress, r, _ := m.getIngress(ing.Namespace, ing.Name)
	if r != mapperResultUpdate {
		return ing
	}
	if ing.CreationTimestamp.After(upstreamIngress.CreationTimestamp.Time) {
		return ing
	}
	return upstreamIngress
}

func (m *mapper) getConverterResult(err error) (mapperResult, error) {
	if err != nil && errors.IsNotFound(err) {
		return mapperResultCreate, nil
	} else if err != nil {
		return mapperResultError, err
	}
	return mapperResultUpdate, nil
}
