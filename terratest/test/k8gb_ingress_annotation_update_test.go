package test

/*
Copyright 2022 The k8gb Contributors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Generated by GoLic, for more details see: https://github.com/AbsaOSS/golic
*/

import (
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"k8gbterratest/utils"
)

func TestIngressAnnotationUpdateWhenClusterIsReady(t *testing.T) {
	t.Parallel()
	const host = "terratest-roundrobin.cloud.example.com"
	const endpointDNSNameEU = "gslb-ns-eu-cloud.example.com"
	const gslbPath = "../examples/roundrobin_weight1.yaml"
	testGslb1, err := utils.NewWorkflow(t, "k3d-test-gslb1", 5053).
		WithGslb(gslbPath, host).
		WithTestApp("eu").
		Start()
	require.NoError(t, err)
	defer testGslb1.Kill()

	err = testGslb1.WaitForAppIsRunning()
	require.NoError(t, err)

	err = testGslb1.WaitForExternalDNSEndpointExists()
	require.NoError(t, err)

	err = testGslb1.WaitForLocalDNSEndpointExists()
	require.NoError(t, err)

	err = testGslb1.Resources().WaitForExternalDNSEndpointHasTargets(endpointDNSNameEU)
	require.NoError(t, err)

	patchAnnotations := map[string]string{}
	patchAnnotations["k8gb.io/protocol"] = "undefined"
	patchAnnotations["k8gb.io/primary-geotag"] = "na"
	err = testGslb1.Resources().Ingress().PatchAnnotations(patchAnnotations)
	require.NoError(t, err)
	time.Sleep(5 * time.Second)
	newAnnotations := testGslb1.Resources().Ingress().GetAnnotations()
	assert.Equal(t, 4, len(newAnnotations))
	assert.Equal(t, "undefined", newAnnotations["k8gb.io/protocol"])
	assert.Equal(t, "na", newAnnotations["k8gb.io/primary-geotag"])
	assert.Equal(t, "roundRobin", newAnnotations["k8gb.io/strategy"])
	assert.NotEmpty(t, newAnnotations["kubectl.kubernetes.io/last-applied-configuration"])
}

func TestIngressAnnotationUpdateRepeatedly(t *testing.T) {
	t.Parallel()
	const host = "terratest-roundrobin.cloud.example.com"
	const gslbPath = "../examples/roundrobin_weight1.yaml"
	const key = "k8gb.io/ep.ips"
	testGslb1, err := utils.NewWorkflow(t, "k3d-test-gslb1", 5053).
		WithGslb(gslbPath, host).
		WithTestApp("eu").
		Start()
	require.NoError(t, err)
	defer testGslb1.Kill()

	err = testGslb1.WaitForAppIsRunning()
	require.NoError(t, err)

	for _, v := range []string{"10.0.0.1", "10.0.0.2", "10.0.0.3", "10.0.0.4"} {
		patchAnnotations := map[string]string{}
		patchAnnotations[key] = v
		err = testGslb1.Resources().Ingress().PatchAnnotations(patchAnnotations)
		require.NoError(t, err)
		time.Sleep(3 * time.Second)
		newAnnotations := testGslb1.Resources().Ingress().GetAnnotations()
		assert.Equal(t, 3, len(newAnnotations))
		assert.Equal(t, v, newAnnotations["k8gb.io/ep.ips"])
	}
}

func TestGslbModifiesAllowedIngressAnnotationRepeatedly(t *testing.T) {
	t.Parallel()
	const host = "terratest-roundrobin.cloud.example.com"
	const gslbPath = "../examples/roundrobin_weight1.yaml"
	const ipKey = "k8gb.io/ep.ips"
	const strategyKey = "k8gb.io/strategy"
	testGslb1, err := utils.NewWorkflow(t, "k3d-test-gslb1", 5053).
		WithGslb(gslbPath, host).
		WithTestApp("eu").
		Start()
	require.NoError(t, err)
	defer testGslb1.Kill()

	err = testGslb1.WaitForAppIsRunning()
	require.NoError(t, err)
	initialStrategy := testGslb1.Resources().Gslb().GslbSpecProperty(".spec.strategy.type")
	data := []struct {
		ip       string
		strategy string
	}{{"10.0.0.1", "unknown1"}, {"10.100.0.1", "unknown2"}, {"10.200.0.1", "unknown3"}}

	for _, v := range data {
		patchAnnotations := map[string]string{}
		// "k8gb.io/ep.ips" is not synced with ingress. However I change the value in GSLB, it will not pass the allowedMerge filter
		// "k8gb.io/strategy" is synchronized with gslb, but the annotation is forcibly changed to `.spec.strategy.type` during reconciliation.
		// However I change the annotation in GSLB, the computed annotation in the ingress will always come from .spec.strategy.type
		patchAnnotations[ipKey] = v.ip
		patchAnnotations[strategyKey] = v.strategy
		err = testGslb1.Resources().Gslb().PatchAnnotations(patchAnnotations)
		require.NoError(t, err)

		time.Sleep(3 * time.Second)

		ingressAnnotations := testGslb1.Resources().Ingress().GetAnnotations()
		assert.Equal(t, 2, len(ingressAnnotations))
		ips := ingressAnnotations[ipKey]
		assert.Equal(t, "", ips)
		strategy := ingressAnnotations[strategyKey]
		assert.Equal(t, initialStrategy, strategy)

		gslbAnnotations := testGslb1.Resources().Gslb().GetAnnotations()
		assert.Equal(t, 3, len(gslbAnnotations))
		ips = gslbAnnotations[ipKey]
		assert.Equal(t, v.ip, ips)
		strategy = gslbAnnotations[strategyKey]
		assert.Equal(t, strategy, strategy)
	}
}
